-- Migration: core schema with business tables, policies, and scheduled tasks
-- Generated by ChatGPT

-- Enable extensions required for features in this schema
create extension if not exists "uuid-ossp";
create extension if not exists pgcrypto;
create extension if not exists btree_gist;
create extension if not exists pg_trgm;
create extension if not exists pg_cron;
create extension if not exists citext;

-- Shared schema for application data
create schema if not exists app_public;

-- Helper function to maintain updated_at
create or replace function app_public.touch_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at := timezone('utc', now());
  return new;
end;
$$;

-- Organisations (tenants) allow optional multi-tenancy
create table if not exists app_public.organisations (
  id uuid primary key default gen_random_uuid(),
  slug citext not null unique,
  name text not null,
  billing_email citext,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);
create trigger organisations_touch_updated_at
before update on app_public.organisations
for each row execute procedure app_public.touch_updated_at();

-- Profiles extend auth.users
create table if not exists app_public.profiles (
  id uuid primary key references auth.users (id) on delete cascade,
  tenant_id uuid references app_public.organisations (id) on delete set null,
  role text not null check (role in ('customer', 'staff', 'admin')),
  full_name text,
  phone text,
  avatar_url text,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  unique (tenant_id, phone)
);
create index if not exists profiles_tenant_role_idx on app_public.profiles (tenant_id, role);
create trigger profiles_touch_updated_at
before update on app_public.profiles
for each row execute procedure app_public.touch_updated_at();

-- Services offered for booking
create table if not exists app_public.services (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid references app_public.organisations (id) on delete cascade,
  name text not null,
  description text,
  duration_minutes integer not null check (duration_minutes > 0),
  price_cents integer not null check (price_cents >= 0),
  currency char(3) not null default 'USD',
  buffer_minutes integer not null default 0 check (buffer_minutes >= 0),
  active boolean not null default true,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);
create index if not exists services_tenant_active_idx on app_public.services (tenant_id, active);
create trigger services_touch_updated_at
before update on app_public.services
for each row execute procedure app_public.touch_updated_at();

-- Staff availability template
create table if not exists app_public.staff_availability (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid references app_public.organisations (id) on delete cascade,
  staff_id uuid not null references app_public.profiles (id) on delete cascade,
  weekday smallint not null check (weekday between 0 and 6),
  start_time time not null,
  end_time time not null,
  capacity smallint not null default 1 check (capacity > 0),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  unique (tenant_id, staff_id, weekday, start_time, end_time)
);
create index if not exists staff_availability_staff_idx on app_public.staff_availability (staff_id, weekday);
create trigger staff_availability_touch_updated_at
before update on app_public.staff_availability
for each row execute procedure app_public.touch_updated_at();

-- Appointment bookings with exclusion constraint preventing overlap
create table if not exists app_public.appointments (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid references app_public.organisations (id) on delete cascade,
  service_id uuid not null references app_public.services (id) on delete cascade,
  customer_id uuid not null references app_public.profiles (id) on delete restrict,
  staff_id uuid not null references app_public.profiles (id) on delete restrict,
  start_at timestamptz not null,
  end_at timestamptz not null,
  slot tstzrange generated always as (tstzrange(start_at, end_at, '[)')) stored,
  status text not null default 'pending' check (status in ('pending','confirmed','completed','cancelled')),
  notes text,
  source text,
  total_price_cents integer check (total_price_cents >= 0),
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);
create index if not exists appointments_tenant_idx on app_public.appointments (tenant_id, start_at);
create index if not exists appointments_staff_idx on app_public.appointments (staff_id, start_at);
alter table app_public.appointments
  add constraint appointments_no_overlap
  exclude using gist (
    staff_id with =,
    slot with &&
  )
  where (status in ('pending','confirmed'));
create trigger appointments_touch_updated_at
before update on app_public.appointments
for each row execute procedure app_public.touch_updated_at();

-- Products and stock management
create table if not exists app_public.products (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid references app_public.organisations (id) on delete cascade,
  sku text not null,
  name text not null,
  description text,
  price_cents integer not null check (price_cents >= 0),
  currency char(3) not null default 'USD',
  active boolean not null default true,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  unique (tenant_id, sku)
);
create index if not exists products_active_idx on app_public.products (tenant_id, active);
create trigger products_touch_updated_at
before update on app_public.products
for each row execute procedure app_public.touch_updated_at();

create table if not exists app_public.product_stock (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid references app_public.organisations (id) on delete cascade,
  product_id uuid not null references app_public.products (id) on delete cascade,
  quantity integer not null check (quantity >= 0),
  reserved integer not null default 0 check (reserved >= 0),
  available_at timestamptz not null default timezone('utc', now()),
  expires_at timestamptz,
  released boolean not null default false,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);
create index if not exists product_stock_availability_idx
  on app_public.product_stock (tenant_id, product_id, available_at)
  where released = false;
create trigger product_stock_touch_updated_at
before update on app_public.product_stock
for each row execute procedure app_public.touch_updated_at();

create or replace function app_public.reserve_product_stock(
  p_product_id uuid,
  p_quantity integer,
  p_customer_id uuid
)
returns app_public.product_stock
language plpgsql
security definer
set search_path = app_public, public
as $$
declare
  v_row app_public.product_stock;
begin
  if p_quantity <= 0 then
    raise exception 'Quantity must be positive';
  end if;
  select *
    into v_row
    from app_public.product_stock
   where product_id = p_product_id
     and released = false
   order by available_at
   for update skip locked
   limit 1;
  if not found then
    raise exception 'No stock available';
  end if;
  if v_row.quantity - v_row.reserved < p_quantity then
    raise exception 'Insufficient stock';
  end if;

  update app_public.product_stock
     set reserved = reserved + p_quantity,
         updated_at = timezone('utc', now())
   where id = v_row.id
  returning * into v_row;

  insert into app_public.audit_log (tenant_id, actor_id, actor_role, action, resource, changes)
  values (v_row.tenant_id, p_customer_id, 'customer', 'stock_reserved', v_row.product_id::text,
          jsonb_build_object('reserved', p_quantity))
  on conflict do nothing;

  return v_row;
end;
$$;

create or replace function app_public.release_product_stock(
  p_stock_id uuid,
  p_quantity integer,
  p_reason text
)
returns app_public.product_stock
language plpgsql
security definer
set search_path = app_public, public
as $$
declare
  v_row app_public.product_stock;
  v_release integer;
begin
  select * into v_row from app_public.product_stock where id = p_stock_id for update;
  if not found then
    raise exception 'Stock row not found';
  end if;
  v_release := least(p_quantity, v_row.reserved);
  update app_public.product_stock
     set reserved = reserved - v_release,
         updated_at = timezone('utc', now())
   where id = p_stock_id
  returning * into v_row;
  insert into app_public.audit_log (tenant_id, actor_id, actor_role, action, resource, changes)
  values (v_row.tenant_id, null, 'system', 'stock_released', v_row.product_id::text,
          jsonb_build_object('released', v_release, 'reason', p_reason))
  on conflict do nothing;
  return v_row;
end;
$$;

-- Orders and order line items
create table if not exists app_public.orders (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid references app_public.organisations (id) on delete cascade,
  customer_id uuid references app_public.profiles (id) on delete set null,
  status text not null default 'draft' check (status in ('draft','pending','paid','cancelled','fulfilled','refunded')),
  total_cents integer not null default 0 check (total_cents >= 0),
  currency char(3) not null default 'USD',
  payment_intent_id text,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  metadata jsonb not null default '{}'::jsonb
);
create index if not exists orders_customer_idx on app_public.orders (customer_id, created_at desc);
create trigger orders_touch_updated_at
before update on app_public.orders
for each row execute procedure app_public.touch_updated_at();

create table if not exists app_public.order_items (
  id uuid primary key default gen_random_uuid(),
  order_id uuid not null references app_public.orders (id) on delete cascade,
  product_id uuid references app_public.products (id) on delete set null,
  appointment_id uuid references app_public.appointments (id) on delete set null,
  description text,
  quantity integer not null check (quantity > 0),
  unit_price_cents integer not null check (unit_price_cents >= 0),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);
create index if not exists order_items_order_idx on app_public.order_items (order_id);
create trigger order_items_touch_updated_at
before update on app_public.order_items
for each row execute procedure app_public.touch_updated_at();

-- Voucher codes
create table if not exists app_public.vouchers (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid references app_public.organisations (id) on delete cascade,
  code text not null,
  type text not null check (type in ('amount','percent')),
  amount_cents integer check (amount_cents >= 0),
  percent integer check (percent between 0 and 100),
  max_redemptions integer,
  redemptions integer not null default 0,
  starts_at timestamptz,
  ends_at timestamptz,
  metadata jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  unique (tenant_id, code)
);
create index if not exists vouchers_active_idx
on app_public.vouchers (tenant_id, code)
where (starts_at is null or starts_at <= timezone('utc', now()))
  and (ends_at is null or ends_at >= timezone('utc', now()));
create trigger vouchers_touch_updated_at
before update on app_public.vouchers
for each row execute procedure app_public.touch_updated_at();

-- Idempotency store for edge functions
create table if not exists app_public.idempotency_keys (
  key text primary key,
  tenant_id uuid,
  request_hash text not null,
  response jsonb,
  created_at timestamptz not null default timezone('utc', now()),
  expires_at timestamptz not null default timezone('utc', now()) + interval '7 days'
);
create index if not exists idempotency_keys_expires_idx on app_public.idempotency_keys (expires_at);

-- CMS content tables
create table if not exists app_public.cms_pages (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid references app_public.organisations (id) on delete cascade,
  slug text not null,
  title text not null,
  status text not null default 'draft' check (status in ('draft','published','archived')),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  unique (tenant_id, slug)
);
create table if not exists app_public.cms_blocks (
  id uuid primary key default gen_random_uuid(),
  page_id uuid not null references app_public.cms_pages (id) on delete cascade,
  position integer not null,
  kind text not null,
  content jsonb not null,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);
create trigger cms_pages_touch_updated_at
before update on app_public.cms_pages
for each row execute procedure app_public.touch_updated_at();
create trigger cms_blocks_touch_updated_at
before update on app_public.cms_blocks
for each row execute procedure app_public.touch_updated_at();

-- Audit log - immutable
create table if not exists app_public.audit_log (
  id bigserial primary key,
  tenant_id uuid,
  actor_id uuid,
  actor_role text,
  action text not null,
  resource text,
  changes jsonb,
  created_at timestamptz not null default timezone('utc', now())
);
comment on table app_public.audit_log is 'Append-only audit log. Updates and deletes are blocked.';

create or replace function app_public.prevent_audit_mutation()
returns trigger
language plpgsql
as $$
begin
  raise exception 'audit_log is immutable';
end;
$$;

create trigger audit_log_no_update
  before update on app_public.audit_log
  for each row execute procedure app_public.prevent_audit_mutation();
create trigger audit_log_no_delete
  before delete on app_public.audit_log
  for each row execute procedure app_public.prevent_audit_mutation();

-- Files bucket policies use storage.objects, but ensure metadata table for uploads
create table if not exists app_public.uploads (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid references app_public.organisations (id) on delete cascade,
  bucket text not null,
  path text not null,
  owner_id uuid references app_public.profiles (id) on delete set null,
  created_at timestamptz not null default timezone('utc', now())
);
create unique index if not exists uploads_unique_path on app_public.uploads (bucket, path);

-- Observability configuration placeholders
create table if not exists app_public.error_reports (
  id uuid primary key default gen_random_uuid(),
  tenant_id uuid,
  payload jsonb not null,
  created_at timestamptz not null default timezone('utc', now())
);

-- Schedules for pg_cron tasks
select cron.schedule(
  'cleanup_idempotency',
  '0 3 * * *',
  $$delete from app_public.idempotency_keys where expires_at < timezone('utc', now());$$
)
where not exists (select 1 from cron.job where jobname = 'cleanup_idempotency');

select cron.schedule(
  'cleanup_expired_stock',
  '15 * * * *',
  $$update app_public.product_stock set released = true where released = false and expires_at is not null and expires_at < timezone('utc', now());$$
)
where not exists (select 1 from cron.job where jobname = 'cleanup_expired_stock');

select cron.schedule(
  'send_appointment_reminders',
  '*/30 * * * *',
  $$insert into app_public.audit_log (action, resource, changes)
    select 'reminder_sent', 'appointment:' || id::text, jsonb_build_object('start_at', start_at)
    from app_public.appointments
    where status = 'confirmed'
      and start_at between timezone('utc', now()) and timezone('utc', now()) + interval '24 hours';$$
)
where not exists (select 1 from cron.job where jobname = 'send_appointment_reminders');

select cron.schedule(
  'daily_backup_marker',
  '0 2 * * *',
  $$insert into app_public.audit_log (action, resource, changes)
    values ('backup_started', 'system', jsonb_build_object('timestamp', timezone('utc', now())));$$
)
where not exists (select 1 from cron.job where jobname = 'daily_backup_marker');

-- Row level security policies -------------------------------------------------

alter table app_public.organisations enable row level security;
alter table app_public.profiles enable row level security;
alter table app_public.services enable row level security;
alter table app_public.staff_availability enable row level security;
alter table app_public.appointments enable row level security;
alter table app_public.products enable row level security;
alter table app_public.product_stock enable row level security;
alter table app_public.orders enable row level security;
alter table app_public.order_items enable row level security;
alter table app_public.vouchers enable row level security;
alter table app_public.cms_pages enable row level security;
alter table app_public.cms_blocks enable row level security;
alter table app_public.audit_log enable row level security;
alter table app_public.uploads enable row level security;
alter table app_public.error_reports enable row level security;

-- Helper policies referencing auth.jwt() claims for tenant + role
create or replace function app_public.current_role()
returns text
language sql stable
as $$
  select coalesce(nullif((auth.jwt() ->> 'role'), ''), 'customer');
$$;

create or replace function app_public.current_tenant()
returns uuid
language sql stable
as $$
  select nullif(auth.jwt() ->> 'tenant_id', '')::uuid;
$$;

-- Organisations policies
create policy organisations_admin_read on app_public.organisations
  for select
  using (
    app_public.current_role() in ('staff','admin')
  );
create policy organisations_admin_write on app_public.organisations
  for all
  using (app_public.current_role() = 'admin')
  with check (app_public.current_role() = 'admin');

-- Profiles policies
create policy profiles_self_read on app_public.profiles
  for select
  using (
    id = auth.uid() or app_public.current_role() in ('staff','admin')
  );
create policy profiles_self_update on app_public.profiles
  for update
  using (
    id = auth.uid()
  )
  with check (
    coalesce(tenant_id, app_public.current_tenant()) is not distinct from app_public.current_tenant()
  );
create policy profiles_admin_manage on app_public.profiles
  for all
  using (app_public.current_role() = 'admin')
  with check (app_public.current_role() = 'admin');

-- Services policies
create policy services_public_read on app_public.services
  for select
  using (
    tenant_id is null or tenant_id = app_public.current_tenant()
  );
create policy services_staff_manage on app_public.services
  for all
  using (app_public.current_role() in ('staff','admin'))
  with check (tenant_id = app_public.current_tenant());

-- Staff availability policies
create policy staff_availability_read on app_public.staff_availability
  for select
  using (
    tenant_id = app_public.current_tenant()
  );
create policy staff_availability_manage on app_public.staff_availability
  for all
  using (app_public.current_role() in ('staff','admin'))
  with check (tenant_id = app_public.current_tenant());

-- Appointments policies
create policy appointments_customer_read on app_public.appointments
  for select
  using (
    tenant_id = app_public.current_tenant()
    and (customer_id = auth.uid() or app_public.current_role() in ('staff','admin'))
  );
create policy appointments_customer_insert on app_public.appointments
  for insert
  with check (
    tenant_id = app_public.current_tenant()
    and customer_id = auth.uid()
  );
create policy appointments_customer_update on app_public.appointments
  for update
  using (
    customer_id = auth.uid()
    and status in ('pending','confirmed')
  )
  with check (
    tenant_id = app_public.current_tenant()
  );
create policy appointments_staff_manage on app_public.appointments
  for all
  using (app_public.current_role() in ('staff','admin'))
  with check (tenant_id = app_public.current_tenant());

-- Products policies
create policy products_public_read on app_public.products
  for select
  using (
    tenant_id = app_public.current_tenant() or app_public.current_role() = 'admin'
  );
create policy products_staff_manage on app_public.products
  for all
  using (app_public.current_role() in ('staff','admin'))
  with check (tenant_id = app_public.current_tenant());

-- Product stock
create policy stock_public_read on app_public.product_stock
  for select
  using (
    tenant_id = app_public.current_tenant()
  );
create policy stock_staff_manage on app_public.product_stock
  for all
  using (app_public.current_role() in ('staff','admin'))
  with check (tenant_id = app_public.current_tenant());

-- Orders
create policy orders_customer_read on app_public.orders
  for select
  using (
    tenant_id = app_public.current_tenant() and (customer_id = auth.uid() or app_public.current_role() in ('staff','admin'))
  );
create policy orders_customer_insert on app_public.orders
  for insert
  with check (
    tenant_id = app_public.current_tenant() and customer_id = auth.uid()
  );
create policy orders_customer_update on app_public.orders
  for update
  using (customer_id = auth.uid())
  with check (tenant_id = app_public.current_tenant());
create policy orders_staff_manage on app_public.orders
  for all
  using (app_public.current_role() in ('staff','admin'))
  with check (tenant_id = app_public.current_tenant());

-- Order items
create policy order_items_read on app_public.order_items
  for select
  using (
    exists (
      select 1 from app_public.orders o
      where o.id = order_id
        and o.tenant_id = app_public.current_tenant()
        and (o.customer_id = auth.uid() or app_public.current_role() in ('staff','admin'))
    )
  );
create policy order_items_manage on app_public.order_items
  for all
  using (app_public.current_role() in ('staff','admin'))
  with check (
    exists (
      select 1 from app_public.orders o
      where o.id = order_id and o.tenant_id = app_public.current_tenant()
    )
  );

-- Vouchers
create policy vouchers_read on app_public.vouchers
  for select
  using (tenant_id = app_public.current_tenant());
create policy vouchers_staff_manage on app_public.vouchers
  for all
  using (app_public.current_role() in ('staff','admin'))
  with check (tenant_id = app_public.current_tenant());

-- CMS
create policy cms_read on app_public.cms_pages
  for select
  using (
    tenant_id = app_public.current_tenant()
    and (status = 'published' or app_public.current_role() in ('staff','admin'))
  );
create policy cms_manage on app_public.cms_pages
  for all
  using (app_public.current_role() in ('staff','admin'))
  with check (tenant_id = app_public.current_tenant());
create policy cms_blocks_manage on app_public.cms_blocks
  for all
  using (app_public.current_role() in ('staff','admin'))
  with check (
    exists (
      select 1 from app_public.cms_pages p
      where p.id = page_id and p.tenant_id = app_public.current_tenant()
    )
  );

-- Audit log read only for admins
create policy audit_log_admin on app_public.audit_log
  for select
  using (app_public.current_role() = 'admin');

-- Uploads
create policy uploads_read on app_public.uploads
  for select
  using (
    tenant_id = app_public.current_tenant()
  );
create policy uploads_manage on app_public.uploads
  for all
  using (
    app_public.current_role() in ('staff','admin') or owner_id = auth.uid()
  )
  with check (
    tenant_id = app_public.current_tenant()
  );

-- Error reports restricted to service role by default
create policy error_reports_service_role on app_public.error_reports
  for insert
  with check (auth.role() = 'service_role');
create policy error_reports_admin_read on app_public.error_reports
  for select
  using (app_public.current_role() = 'admin');

-- Storage policies (requires storage bucket to exist separately)
do $$
begin
  create policy "Customers read own files" on storage.objects
    for select using (
      bucket_id = 'uploads' and (auth.role() = 'service_role' or metadata ->> 'owner_id' = auth.uid()::text)
    );
exception when duplicate_object then null;
end $$;

do $$
begin
  create policy "Customers upload own files" on storage.objects
    for insert with check (
      bucket_id = 'uploads' and (auth.role() = 'service_role' or metadata ->> 'owner_id' = auth.uid()::text)
    );
exception when duplicate_object then null;
end $$;

do $$
begin
  create policy "Staff manage tenant files" on storage.objects
    for all using (
      bucket_id = 'uploads' and app_public.current_role() in ('staff','admin')
    )
    with check (
      bucket_id = 'uploads' and app_public.current_role() in ('staff','admin')
    );
exception when duplicate_object then null;
end $$;

-- Index to ensure fast audit queries by tenant/time
create index if not exists audit_log_tenant_created_idx on app_public.audit_log (tenant_id, created_at desc);

grant usage on schema app_public to authenticated, anon;
grant usage on all sequences in schema app_public to authenticated;
grant usage on all sequences in schema app_public to anon;
grant select, insert, update, delete on all tables in schema app_public to authenticated;
grant select on all tables in schema app_public to anon;

